package Garmin::FIT::Streamer::Type;
use strict;
use warnings;

our $VERSION = '1.000';

use Carp;

our $types;
require Garmin::FIT::Streamer::BaseType;

our @CARP_NOT = qw(Garmin::FIT::Streamer::BaseType);

sub types {
    return $types;
}

sub new {
    my ($class, %params) = @_;

    my %type;
    defined($type{name} = delete $params{name}) ||
        croak "Missing parameter 'name'";
    defined($type{base_type} = delete $params{base_type}) ||
        croak "Missing parameter 'base_type'";
    if (ref $type{base_type} eq "") {
        $type{base_type} =
            Garmin::FIT::Streamer::BaseType->from_id($type{base_type});
    } elsif (!eval { $type{base_type}->isa("Garmin::FIT::Streamer::BaseType") }) {
        croak "Parameter 'base_type' is neither a name nor a Garmin::FIT::Streamer::BaseType but '$type{base_type}'";
    }
    my $comment = delete $params{comment};
    $type{comment} = $comment if defined $comment;
    if (defined(my $values = delete $params{values})) {
        my $regex = $type{base_type}->regex ||
            croak "BaseType '", $type{base_type}->name, "' doesn't allow values";
        ref $values eq "HASH" || ref $values eq "ARRAY" ||
            croak "Parameter 'values' is not a HASH or ARRAY reference but '$values'";
        if (ref $values eq "HASH" && %$values) {
            $type{values} = \my %values;
            for my $name (keys %$values) {
                croak "Value name '$name' can match values" if $name =~ $regex;
                defined $values->{$name} || croak "Value '$name' is undefined";
                # Maybe allow this to give a name to the invalid value
                ref $values->{$name} eq "" ||
                    croak "Value '$name' is not a plain value but '$values->{$name}'";
                $values->{$name} =~ $regex ||
                    croak "Value '$name' is not a valid '", $type{base_type}->name, "' BaseType but '$values->{$name}'";
                croak "Already have a value named '$name'" if $values{lc $name};
                croak "Already have a value valued '$values->{$name}'" if
                    $values{lc $values->{name}};
                $values{lc $name} = $values{lc $values->{name}} = {
                    name	=> $name,
                    value	=> $values->{$name} =~ /^\s*(-?[0-9]+)\s*\z/ ?
                        int($1) : $values->{$name},
                };
            }
        } elsif (ref $values eq "ARRAY" && @$values) {
            $type{values} = \my %values;
            for my $value (@$values) {
                ref $value eq "HASH" ||
                    croak defined $value ?
                        "Value is not a HASH reference but '$value'" :
                        "Undefined value";
                my %value = %$value;
                # Allow value_name and value for easy profile parsing
                my $name =
                    exists $value{name} ? delete $value{name} :
                    exists $value{value_name} ? delete $value{value_name} :
                    croak "Value has no name or value_name";
                defined $name || croak "Undefined value name";
                croak "Value name '$name' can match values" if $name =~ $regex;

                defined(my $val = delete $value{value}) ||
                    croak "Value '$name' is undefined";
                $val =~ $regex ||
                    croak "Value '$name' is not a valid '", $type{base_type}->name, "' BaseType but '$val'";
                my $comment = delete $value{comment};
                croak "Already have a value named '$name'" if $values{lc $name};
                croak "Already have a value valued '$val'" if $values{lc $val};
                $values{lc $name} = $values{lc $val} = {
                    name	=> $name,
                    # Wrong really. The user regex might allow more than integers
                    # (floats/doubles in particular).
                    # But currently I want real perl integers so they look good
                    # in the autogenerated Profile (+0 doesn't always make an IV)
                    value	=> $val  =~ /^\s*(-?[0-9]+)\s*\z/ ?
                        int($1) : $val,
                    defined $comment ? (comment => $comment) : (),
                };
                croak "Unknown value parameter ", join(", ", keys %value) if %value;
            }
        }
    }

    croak "Unknown parameter ", join(", ", keys %params) if %params;

    croak "Already have a Type named '$type{name}'" if $types->{lc $type{name}};
    return $types->{lc $type{name}} = bless \%type, $class;
}

sub name {
    return shift->{name};
}

sub values {
    return shift->{values};
}

sub base_type {
    return shift->{base_type};
}

sub from_id {
    defined $_[1] || croak "No type id argument";
    return $types->{lc $_[1]} || croak "Unknown type id '$_[1]'";
}

1;

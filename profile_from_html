#!/usr/bin/perl -w
use strict;
use warnings;

our $VERSION = "1.000";

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

my %base_types = (
    0x00	=> {
        name	=> "enum",
        size	=> 1,
        decoder	=> ["C", "C"],
        invalid	=> 0xff,
        notice	=> 1,
    },
    0x01	=> {
        name	=> "sint8",
        size	=> 1,
        decoder	=> ["c", "c"],
        invalid	=> 0x7f,
        notice	=> 1,
    },
    0x02	=> {
        name	=> "uint8",
        size	=> 1,
        decoder	=> ["C", "C"],
        invalid	=> 0xff,
        notice	=> 1,
    },
    0x83	=> {
        name	=> "sint16",
        size	=> 2,
        decoder	=> ["v!", "n!"],
        invalid	=> 0x7fff,
        notice	=> 1,
    },
    0x84	=> {
        name	=> "uint16",
        size	=> 2,
        decoder	=> ["v", "n"],
        invalid	=> 0xffff,
        notice	=> 1,
    },
    0x85	=> {
        name	=> "sint32",
        size	=> 4,
        decoder	=> ["V!", "N!"],
        invalid	=> 0x7fffffff,
        notice	=> 1,
    },
    0x86	=> {
        name	=> "uint32",
        size	=> 4,
        decoder	=> ["V", "N"],
        invalid	=> 0xffffffff,
        notice	=> 1,
    },
    0x07	=> {
        name	=> "string",
        size	=> 0,
        decoder	=> ["Z", "Z"],
        invalid	=> "",
        notice	=> 1,
    },
    0x88	=> {
        name	=> "float32",
        size	=> 4,
        decoder	=> ["f<", "f>"],
        invalid	=> 0xffffffff,
        notice	=> 1,
    },
    0x89	=> {
        name	=> "float64",
        size	=> 4,
        decoder	=> ["d<", "d>"],
        invalid	=> 0xffffffffffffffff,
        notice	=> 1,
    },
    0x0A	=> {
        name	=> "uint8z",
        size	=> 1,
        decoder	=> ["C", "C"],
        invalid	=> 0x00,
        notice	=> 1,
    },
    0x8B	=> {
        name	=> "uint16z",
        size	=> 2,
        decoder	=> ["v", "n"],
        invalid	=> 0x0000,
        notice	=> 1,
    },
    0x8C	=> {
        name	=> "uint32z",
        size	=> 4,
        decoder	=> ["V", "N"],
        invalid	=> 0x00000000,
        notice	=> 1,
    },
    0x0D	=> {
        name	=> "byte",
        size	=> 0,
        decoder	=> ["a", "a"],
        invalid	=> 0xff,
        notice	=> 1,
    },
);
for my $num (keys %base_types) {
    my $base_type = $base_types{$num};
    $base_type->{number} = $num+0;
    $base_types{lc $base_type->{name}} = $base_type;
}

my %keep_tag = map(($_ => 1), qw(body h1 h2 h3 h4 h5 h6 table tr td));

sub get_context {
    # A context should be a consistent single column row
    my $context;
    my $i = 0;
    my $rows = shift;
    for my $row (@$rows) {
        $i++;
        next if $row eq "";
        die "Not a context row '@$rows'" if defined $context;
        $context = $row;
        if (defined $_[0]) {
            $_[0] == $i || die "Inconsistent context column $_[0] vs @$rows";
        } else {
            $_[0] = $i;
        }
    }
    return $context;
}

sub spew {
    my ($file, $content) = @_;
    my $new = "$file.new";
    open(my $fh, ">", $new) || die "Could not open '$new': $!";
    eval {
        print($fh $content) || die "Error writing to '$new': $!";
        close($fh) || die "Could not close '$new': $!";
        rename($new, $file) || die "Could not rename '$new' to '$file' $!";
    };
    if ($@) {
        $fh = undef;
        unlink($new) || die "Could not unlink '$new': $! after $@";
        die $@;
    }
}

# Do a basic parse of the HTML file into a perl data structure
sub sheets_from_html {
    my ($html_file) = @_;

    open(my $ifh, "<", $html_file) || die "Could not open '$html_file': $!";
    my $html = do { local $/; <$ifh> };
    close($ifh) || die "Could not close '$html_file': $!";

    # Normalize attributes
    $html =~ s{<(/?)(\w+).*?(/?)>}{$keep_tag{lc $2} ? "<$1\L$2$3>" : ""}eg;
    my (%sheets, $sheet_name);
    while ($html =~ s{(.*?)<h(\d+)>Sheet\s+\d+:\s*([^<]*?)</h\2>}{}s) {
        $sheets{$sheet_name} = $1 if defined $sheet_name;
        $sheet_name = lc $3;
        die "Already have a sheet named '$sheet_name'" if $sheets{$sheet_name};
    }
    defined $sheet_name || die "Found no sheets";
    $sheets{$sheet_name} = $html;

    for my $sheet_name (sort keys %sheets) {
        eval {
            my ($html) = $sheets{$sheet_name} =~ m{<table>\s*(.*)</table>}s or
            die "Could not find <table> ... </table>";
            my (@rows, $nr_cols);
            while ($html =~ m{<tr>(.*?)</tr>}sg) {
                my @row = $1 =~ m{<td>\s*(.*?)\s*</td>}sg;
                # html unescape
                for (@row) {
                    s/&lt;/</g;
                    s/&gt;/>/g;
                    s/&quot;/"/g;
                    s/&amp;/&/g;
                }
                if (defined $nr_cols) {
                    $nr_cols == @row || die "Inconsistent number of rows";
                } else {
                    $nr_cols = @row;
                }
                push @rows, \@row;
            }
            my $headers = shift @rows || die "No headers";
            my %headers;
            for my $header (@$headers) {
                $header =~ s/#/nr/g;
                $header =~ s/\s+/_/g;
                $header = lc $header;
                die "Dumplicate header '$header'" if $headers{$header};
            }
            my (%tables, $table, $context, $context_index, $offset);
            for my $row (@rows) {
                if ($row->[0] eq "") {
                    if (!defined $table) {
                        $context = get_context($row, $context_index);
                    } elsif ($table) {
                        push @$table, \my %props;
                        my $data;
                        for my $i ($offset..$#$row) {
                            next if $row->[$i] eq "";
                            $props{$headers->[$i]} = $row->[$i] =~ /^0x[0-9a-fA-F]+\z/ ? hex $row->[$i] : $row->[$i];
                            $data ||= 1;
                        }
                        if (!$data) {
                            # We assume an empty line finishes the table
                            pop @$table;
                            $table = undef;
                        }
                    } else {
                        die "Row outside table: @$row";
                    }
                } else {
                    my $table_name = $row->[0];
                    $table = [];
                    $tables{$table_name} = {
                        table	=> $table,
                        defined $context ? (context	=> $context) : (),
                    };
                    $offset = 1;
                    while ($row->[$offset] ne "") {
                        $tables{$table_name}{$headers->[$offset]} = $row->[$offset];
                        $offset++;
                    }
                    # Extra attributes (typically a table comment)
                    for my $i ($offset+1..$#$row) {
                        $tables{$table_name}{$headers->[$i]} = $row->[$i] if
                            $row->[$i] ne "";
                    }
                }
            }
            $sheets{$sheet_name} = \%tables;
        };
        die "Sheet $sheet_name: $@" if $@;
    }
    return \%sheets;
}

sub profile_from_sheets {
    my ($sheets) = @_;
    my %profile;

    my $messages = $sheets->{messages} || die "No messages sheet";
    my $types	 = $sheets->{types} || die "No types sheet";

    # Fake a bool type
    die "Already have type bool" if $types->{bool};
    $types->{bool} = {
      'base_type' => 'enum',
      'table' => [
        {
          'value' => '0',
          'value_name' => 'no'
        },
        {
          'value' => '1',
          'value_name' => 'yes'
        }
      ]
       };

    for my $type_name (sort keys %$types) {
        eval {
            my $type = $types->{$type_name};
            die "Already have values" if $type->{values};
            $type->{values} = \my %values;
            for my $row (@{$type->{table}}) {
                my $value_name = lc($row->{value_name} || die "No value_name");
                die "Multiple values named '$value_name'" if
                    $values{$value_name};
                $values{$value_name} = $row;
            }
        };
        die "Type '$type_name': $@" if $@;
    }

    my $message_numbers = $types->{mesg_num} || die "No mesg_num type";
    $message_numbers = $message_numbers->{values};
    for my $message_name (sort keys %$messages) {
        eval {
            my $message = $messages->{$message_name};
            die "is a number" if $message_name =~ /^[0-9]+\z/;
            my $message_number = $message_numbers->{lc $message_name} ||
                die "No corresponding mesg_num";
            defined($message_number = $message_number->{value}) ||
                die "No message number value";
            $message_number =~ /^[1-9][0-9]*\z|^0\z/ ||
                die "message number '$message_number' is not a number";

            my %fields;
            for my $row (@{$message->{table}}) {
                defined(my $field_number = $row->{field_def_nr}) || next;
                $field_number =~ /^[1-9][0-9]*\z|^0\z/ ||
                    die "Field number '$field_number' is not a number";
                defined(my $field_name = $row->{field_name}) ||
                    die "Missing field_name";
                die "Field '$field_name' is a number" if
                    $field_name =~ /^[0-9]+\z/;
                defined(my $field_type = $row->{field_type}) ||
                   die "Missing field_type";
                my $base_type = $base_types{lc $field_type};
                if (!$base_type) {
                    my $type = $types->{lc $field_type} ||
                        die "Unknown type '$field_type'";
                    $base_type = $type->{base_type} ||
                        die "No basetype for type '$field_type'";
                    $base_type = $base_types{lc $base_type} ||
                        die "Unknown base_type '$base_type'";
                }

                my %field = (
                    name	=> $field_name,
                    number	=> $field_number+0,
                    base_type	=> $base_type,
                    defined $row->{scale}  ? (scale  => $row->{scale}) : (),
                    defined $row->{offset} ? (offset => $row->{offset}) : (),
                    defined $row->{units}  ? (units  => $row->{units}) : (),
                   );
                die "Multiple fields called $field_name" if
                    $fields{lc $field_name};
                die "Multiple fields numbered $field_number" if
                    $fields{$field_number};
                $fields{lc $field_name} = $fields{$field_number} = \%field;
            }
            %fields || die "No usable rows";

            die "Multiple named profiles" if $profile{lc $message_name};
            die "Multiple numbered profiles" if $profile{$message_number};
            $profile{lc $message_name} = $profile{$message_number} = {
                name	=> $message_name,
                number	=> $message_number+0,
                defined $message->{context} ? (context => $message->{context}) : (),
                defined $message->{comment} ? (comment => $message->{comment}) : (),
                fields	=> \%fields,
            };
        };
        die "Message '$message_name': $@" if $@;
    }
    return \%profile;
}

@ARGV == 3 ||
    die "Syntax: profile_from_html profile_file profile_dump html_file\n";
my ($profile_file, $profile_dump, $html_file) = @ARGV;

# First convert the html to a usable perl data structure
my $sheets = sheets_from_html($html_file);
spew($profile_dump, Dumper($sheets));

# Next construct a usable profile out of the perl data structure
my $profile = profile_from_sheets($sheets);
$profile = do {
    local $Data::Dumper::Varname = "profile";
    local $Data::Dumper::Purity = 1;
    Data::Dumper->Dump([\%base_types, $profile], [qw(base_types profile)]);
};
chomp $profile;

open(my $fh, "<", $profile_file) || die "Could not open '$profile_file': $!";
my $profile_content = do { local $/; <$fh> };
close($fh) || die "Could not close '$profile_file': $!";

$profile_content =~ /\n=cut\s*\z/ ||
    die "File '$profile_file' does not end on =cut";

$profile_content =~ s{
    \n
    \# [^\S\n]* BEGIN [^\S\n]+ GENERATED [^\S\n]* \n
    (.*\n)*
    \# [^\S\n]* END [^\S\n]+ GENERATED [^\S\n]*
    \n
}{
# BEGIN GENERATED
# Generated from file '$html_file' by program '$0'

sub PROFILE_MAJOR() {   1 }
sub PROFILE_MINOR() {  20 }
sub PROFILE_SCALE() { 100 }

sub PROTOCOL_MAJOR() {  1 }
sub PROTOCOL_MINOR() {  0 }
sub PROTOCOL_SCALE() { 16 }

sub PROFILE_VERSION() {
    return PROFILE_MAJOR() * PROFILE_SCALE() + PROFILE_MINOR();
}

sub PROTOCOL_VERSION() {
    return PROTOCOL_MAJOR() * PROTOCOL_SCALE() + PROTOCOL_MINOR();
}

$profile
# END GENERATED
}x || die "Could not find GENERATED marks";

spew($profile_file, $profile_content);
